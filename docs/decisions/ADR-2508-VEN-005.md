---
id: ADR-2508-VEN-005
legacy_id: 0005-task-queue
type: VEN
implements_concept: null  # Will create CON ADR for task orchestration
status: accepted
date: 2025-08-03
title: "Dramatiq with Redis backend"

decision_confidence: 8
time_investment: "4_hours"
main_tradeoff: "simplicity vs ecosystem_size"
alternatives_rejected: ["celery", "rq", "huey", "custom_asyncio"]
reevaluate_when: "complex_workflow_orchestration_required OR ecosystem_limitations"

supersedes: null
superseded_by: null
research_basis: "Janus Backend Architecture – Onboarding Brief"
linked_evidence:
  - "../reference/Janus Backend Architecture – Onboarding Brief.pdf"
  - "../reference/Redis vs RabbitMQ as Dramatiq Brokers – A Durable Self‑Hosted Task Queue Comparison.pdf"

tags: ["task_queue", "orchestration", "async", "python"]
---

# ADR 0005 – Dramatiq with Redis backend

## Decision

Dramatiq selected as the task queue framework for background job execution and agent workflow orchestration, using Redis for results backend and rate limiting.

## Context

Janus agents require asynchronous task execution for I/O-heavy operations, long-running computations, and concurrent processing that shouldn't block the main agent reasoning loop. The task system must support retries, scheduling, and rate limiting while maintaining reliability.

## Rationale

**Designed for Correctness**: Dramatiq's "designed to be performant and correct from the ground up" philosophy aligns with Janus's reliability requirements. Tasks are only acknowledged after completion, preventing loss on crashes.

**Async/Await Native Support**: First-class async support enables modern Python patterns and efficient resource utilization - critical for agent I/O operations.

**Lightweight Architecture**: Smaller footprint and simpler concurrency model compared to Celery, with fewer configuration pitfalls and more predictable behavior.

**Built-in Middleware**: Automatic retries, timeouts, and rate limiting reduce custom infrastructure code while providing enterprise-grade features.

**Clear API Design**: Decorator-based task definition with "pythonic" patterns reduces cognitive load for agent developers.

## Research Foundation

Detailed evaluation in "Janus Backend Architecture – Onboarding Brief" assessed:

- **Celery**: Rejected due to complexity, legacy design decisions, configuration overhead, and reported stability issues requiring "babysitting in production"
- **Redis Queue (RQ)**: Limited to Redis broker, lacks advanced features like built-in scheduling and robust retry policies
- **Huey**: Too lightweight for scaling requirements, limited broker support
- **Custom asyncio**: Would require reimplementing features Dramatiq provides out-of-box

Research noted: "Celery offers extensive features and scalability options, while Dramatiq focuses on simplicity and lightweight task execution" - simplicity aligned with project priorities.

## Consequences

### Positive
- Reliable task execution with minimal configuration
- Native async support for agent I/O operations
- Built-in rate limiting using Redis Lua scripts (atomic across workers)
- Clean integration with RabbitMQ broker architecture
- Reduced maintenance overhead compared to more complex alternatives

### Negative
- Smaller ecosystem than Celery (fewer third-party integrations)
- Less extensive monitoring tooling available
- Community size smaller for troubleshooting edge cases

### Neutral
- Python-specific solution (appropriate for agent codebase)
- Redis dependency for results and rate limiting

## Implementation Notes

- **Results Backend**: Redis stores task results for retrieval by agent processes
- **Rate Limiting**: Global rate limits enforced via Redis Lua scripts across distributed workers
- **Broker Integration**: RabbitMQ handles task queuing, Redis handles results and coordination
- **Worker Scaling**: Easy horizontal scaling by adding worker processes

## Success Criteria

- [ ] Background tasks execute without blocking agent reasoning
- [ ] Automatic retry handling for transient failures
- [ ] Rate limiting prevents external API abuse
- [ ] Results properly retrieved by requesting agent processes
- [ ] Worker processes recover gracefully from failures

## Integration Notes

**Redis Dual Role**: Redis serves both as results backend and rate limiting coordinator. Lua scripting ensures atomic operations for global rate limits across distributed workers.

**Agent Workflow**: When agents need async operations (web scraping, file processing, etc.), work is packaged as Dramatiq tasks and executed by worker pool while agent continues reasoning.

## Relationships

- **REQUIRES**: RabbitMQ (broker), Redis (results/coordination)
- **ENABLES**: Agent background processing, I/O parallelization, workflow orchestration
- **INTEGRATES_WITH**: All agent services requiring async task execution
