---
id: ADR-2508-VEN-013
legacy_id: 0015-in-memory-cache
type: VEN
implements_concept: null  # Will create CON ADR for caching/session store
status: accepted
date: 2025-08-04
title: "Redis 7 as in-memory cache and transient pub/sub"

decision_confidence: 9
time_investment: "2_hours"
main_tradeoff: "memory_usage vs performance"
alternatives_rejected: ["memcached", "in_process_cache", "rabbitmq_pubsub"]
reevaluate_when: "memory_constraints_critical OR persistence_requirements_change"

supersedes: null
superseded_by: null
research_basis: "Janus Backend Architecture – Onboarding Brief"
linked_evidence:
  - "../reference/Janus Backend Architecture – Onboarding Brief.pdf"
  - "../reference/Janus Backend Architecture – Onboarding Brief.pdf"

tags: ["cache", "session", "pubsub", "performance", "transient"]
---

# ADR 0015 – Redis 7 as in-memory cache and transient pub/sub

## Decision

Redis 7 selected as the in-memory key-value store for ephemeral data, caching, session management, and lightweight pub/sub messaging in Janus.

## Context

Janus requires fast, shared storage for transient data that doesn't warrant persistent database overhead: agent conversation context, computation caches, session state, and real-time coordination signals between components.

## Rationale

**Extreme Performance**: Microsecond response times for in-memory operations enable low-latency agent interactions and rapid cache lookups without impacting reasoning flow.

**Rich Data Structures**: Beyond simple key-value, Redis provides lists, hashes, sets, and sorted sets - enabling sophisticated caching patterns and agent state management.

**Versatile Architecture Role**: Serves multiple system needs without overloading other components:
- **Caching**: Expensive LLM prompt results, computation outputs
- **Session Management**: Agent conversation context, temporary state
- **Coordination**: Lightweight pub/sub for real-time notifications
- **Rate Limiting**: Atomic counters via Lua scripts for Dramatiq

**Offline-First Compatible**: Runs efficiently on modest hardware with configurable persistence options (RDB/AOF) for graceful restarts.

## Research Foundation

Analysis in "Janus Backend Architecture – Onboarding Brief" established clear separation of concerns:

- **Memcached**: Rejected as Redis "essentially supersedes Memcached in functionality with equal performance" while adding pub/sub, persistence options, and advanced data structures
- **In-Process Cache**: Insufficient for multi-worker architectures requiring shared cache state
- **RabbitMQ for Pub/Sub**: Overkill for ephemeral, low-latency notifications where durability isn't required

Research emphasized: "if data can be regenerated or is only needed temporarily, it goes to Redis (not Postgres)"

## Consequences

### Positive
- Sub-millisecond access for frequently used agent data
- Shared cache accessible across distributed agent processes
- Optional persistence prevents complete state loss on restart
- Pub/sub enables real-time UI updates and component coordination
- Lua scripting provides atomic operations for complex logic

### Negative
- Memory-only storage requires careful capacity planning
- Data loss possible if persistence disabled and system crashes
- Single-threaded architecture limits throughput for CPU-intensive operations

### Neutral
- Volatile by design - appropriate for transient data
- Redis-specific commands and patterns vs standard interfaces

## Implementation Notes

- **Dramatiq Integration**: Results backend and rate limiting coordinator
- **Agent Caching**: LLM prompt results, intermediate computations
- **Session Storage**: Conversation context, agent interaction state
- **Pub/Sub Usage**: Real-time notifications, lightweight coordination signals
- **Persistence Strategy**: Configurable RDB snapshots for important cache data

## Success Criteria

- [ ] Cache hit rates improve agent response times measurably
- [ ] Session state persists across agent interactions
- [ ] Pub/sub delivers real-time notifications reliably
- [ ] Rate limiting prevents external service abuse
- [ ] Memory usage stays within configured bounds

## Architectural Boundaries

**Clear Separation**: Redis handles ephemeral data while PostgreSQL manages durable state, preventing architectural confusion and ensuring each system optimizes for its strengths.

## Relationships

- **ENABLES**: Agent performance optimization, session management, real-time coordination
- **INTEGRATES_WITH**: Dramatiq (results/rate limiting), agent services (caching), UI (pub/sub)
- **SUPPORTS**: All system components requiring fast, transient data access
